Debuggers are a category of software that is pretty close to the underlying architecture of your system, the compiler being used and the target process we are trying to debug and so the code we write in this series will not work on windows or macos, its specific to linux, so i recommend using containers or WSL, i will be using wsl myself

we will focus on compilers that compile code down to binary code, like the rust compiler of c/cpp compilers and not the java or c# compilers

the goal of the debugger is to figure out which line in the source code corresponds to the binary code being executed, that information is not included in the compiled executable. we also want the variables to reflect different values at different lines

compilers produce that information but not as part of the release build, all that metadata is part of the build when we use the compiler with debug options

and so we will need to understand the format of the debug information and the structure of the produced binary 

since the format of the debug information also varies from debugger to debugger and platform to platform our code unfortunately will not be very portable at all

the debug information can tell us what compiler was used to generate the binaries, which all files in the FS were used, the names of defined functions and where they will be loaded in the memory when we execute the code, names of variables and where and how to locate them when the program is running, and the lines of source code each binary code belongs on

debugger have the ability to intervene with the execution of other processes and we will use linux sys calls to that

the compiled binary encodes in itself the information required by the OS to setup the environment for the program and load the program, by allocation RAM reserving registers loading libraries

reserving registers is a privileged operation

each process uses virtual memory, its possible that two c programs print the same memory address for some variables because they are both allocated on virtual memory and the OS protects interacting with actual RAM behind syscalls

and since our debugger would want to interact with the RAM of another process we will need to rely on syscalls
syscall on linux to do this is ptrace and it doesnt exist on windows so porting over the code to windows will require some research

processes interact with each other using signals which are essentially integers with predefined expected behaviour, so you can throw the signal integer behind a switch case and invoke different behaviours for different signals as is custom 

the bytecode instructions that CPU understands comprise of two parts, the opCode and the operands the opcode needs
we have 1 byte for the OpCode and 2 bytes for the operands

